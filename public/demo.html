<html>
<head>

<script src="javascripts/three.min.js"></script>
<script src="potree/libs/other/OrbitControls.js"></script>

</head>
<body style="margin: 0px; padding: 0px;">

<script type="text/javascript">

var renderer;
var camera;
var scene;
var pickLocation;
var mouse = { x: 1, y: 1 };
var projector, raycaster;

function HUEtoRGB(hue) {
	if (hue < 0) {
		hue += 1;
	} else if (hue > 1) {
		hue -= 1;
	}
	var rgb = 0;
	if (hue < 1/6) {
		rgb = hue*6;
	} else if (hue < 1/2) {
		rgb = 1;
	} else if (hue < 2/3) {
		rgb = (2/3 - hue)*6;
	}
	return Math.round(rgb * 255);
}

function generatePointCloud() {
	var geometry = new THREE.BufferGeometry();

	var xhr = new XMLHttpRequest();
	xhr.open("GET", "files/datafile.json", false);
	xhr.send(null);
	var max = 0;
	if (xhr.status == 200 || xhr.status == 0) {
		var data = JSON.parse(xhr.responseText);
		positions = new Float32Array(3*data.length);
		colors = new Float32Array(3*data.length);
		for (var i = 0; i < data.length; i++) {
			//Note: order is changed
			positions[3*i] = data[i][2];
			positions[3*i+1] = data[i][0];
			positions[3*i+2] = data[i][1];
			var intensity = data[i][3]/120;
			colors[3*i] =   HUEtoRGB(intensity+1/3);
			colors[3*i+1] = HUEtoRGB(intensity);
			colors[3*i+2] = HUEtoRGB(intensity-1/3);
		}
	}

	geometry.addAttribute('position', new THREE.BufferAttribute(positions, 3));
	geometry.addAttribute('color', new THREE.BufferAttribute(colors, 3));
	
	var material = new THREE.PointCloudMaterial({ size: 0.01, vertexColors: true });
	var pointcloud = new THREE.PointCloud(geometry, material);
	
	return pointcloud;
}

function init() {
	scene = new THREE.Scene();
	camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
	
	projector = new THREE.Projector();
	raycaster = new THREE.Raycaster();

	renderer = new THREE.WebGLRenderer();
	renderer.setSize(window.innerWidth, window.innerHeight);
	document.body.appendChild(renderer.domElement);
	
	pointcloud = generatePointCloud();
	scene.add(pointcloud);
	
	var sphereGeometry = new THREE.SphereGeometry(0.1, 32, 32);
	var sphereMaterial = new THREE.MeshBasicMaterial({color: 0xff0000, shading: THREE.FlatShading});
	pickLocation = new THREE.Mesh(sphereGeometry, sphereMaterial);
	scene.add(pickLocation);
	
	// controls
	camera.position.set(0,10,0);
	controls = new THREE.OrbitControls(camera);
	controls.target.set( 0, 100, 0 );
	camera.lookAt(new THREE.Vector3(0,100,0));
	
	document.addEventListener( 'mousemove', onDocumentMouseMove, false );
}

function onDocumentMouseMove( event ) {
	event.preventDefault();

	mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
	mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
}

function render() {			
	requestAnimationFrame(render);
	
	camera.updateMatrixWorld(true);
	
	vector = new THREE.Vector3( mouse.x, mouse.y, 0.5 );
	projector.unprojectVector( vector, camera );
	raycaster.params = {"PointCloud" : {threshold: 0.1}};
	raycaster.ray.set( camera.position, vector.sub( camera.position ).normalize() );
	
	var intersects = raycaster.intersectObject(pointcloud);
	if(intersects.length > 0){
		var I = intersects[0];
		pickLocation.position.copy(I.point);
	}

	renderer.render(scene, camera);
};

init();
render();

</script>

</body>
</html>
